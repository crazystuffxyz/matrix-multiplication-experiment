use std::env;use std::time::Instant;use rand::Rng;mod win_mem { use std::ffi::c_void; use std::mem;   struct PROCESS_MEMORY_COUNTERS { cb: u32, PageFaultCount: u32, PeakWorkingSetSize: usize, WorkingSetSize: usize, QuotaPeakPagedPoolUsage: usize, QuotaPagedPoolUsage: usize, QuotaPeakNonPagedPoolUsage: usize, QuotaNonPagedPoolUsage: usize, PagefileUsage: usize, PeakPagefileUsage: usize, }  extern "system" { fn GetProcessMemoryInfo( Process: *mut c_void, ppsmemCounters: *mut PROCESS_MEMORY_COUNTERS, cb: u32, ) -> i32; }  extern "system" { fn GetCurrentProcess() -> *mut c_void; } pub fn get_memory_mb() -> f64 { unsafe { let mut pmc: PROCESS_MEMORY_COUNTERS = mem::zeroed(); pmc.cb = mem::size_of::<PROCESS_MEMORY_COUNTERS>() as u32; let process = GetCurrentProcess(); if GetProcessMemoryInfo(process, &mut pmc, pmc.cb) != 0 {  return pmc.WorkingSetSize as f64 / 1024.0 / 1024.0; } } 0.0 }}mod win_mem { pub fn get_memory_mb() -> f64 { 0.0 }}use win_mem::get_memory_mb;type Matrix = Vec<Vec<f64>>;fn create_matrix(n: usize) -> Matrix { let mut rng = rand::thread_rng(); let mut mat = vec![vec![0.0; n]; n]; for i in 0..n { for j in 0..n { mat[i][j] = rng.gen::<f64>(); } } mat}fn naive_multiply(a: &Matrix, b: &Matrix) -> Matrix { let n = a.len(); let mut c = vec![vec![0.0; n]; n]; for i in 0..n { for k in 0..n { for j in 0..n { c[i][j] += a[i][k] * b[k][j]; } } } c}fn add_matrices(a: &Matrix, b: &Matrix) -> Matrix { let n = a.len(); let mut c = vec![vec![0.0; n]; n]; for i in 0..n { for j in 0..n { c[i][j] = a[i][j] + b[i][j]; } } c}fn subtract_matrices(a: &Matrix, b: &Matrix) -> Matrix { let n = a.len(); let mut c = vec![vec![0.0; n]; n]; for i in 0..n { for j in 0..n { c[i][j] = a[i][j] - b[i][j]; } } c}fn split_matrix(p: &Matrix) -> (Matrix, Matrix, Matrix, Matrix) { let n = p.len(); let mid = n / 2; let mut c11 = vec![vec![0.0; mid]; mid]; let mut c12 = vec![vec![0.0; mid]; mid]; let mut c21 = vec![vec![0.0; mid]; mid]; let mut c22 = vec![vec![0.0; mid]; mid]; for i in 0..mid { for j in 0..mid { c11[i][j] = p[i][j]; c12[i][j] = p[i][j + mid]; c21[i][j] = p[i + mid][j]; c22[i][j] = p[i + mid][j + mid]; } } (c11, c12, c21, c22)}fn combine_matrices(c11: &Matrix, c12: &Matrix, c21: &Matrix, c22: &Matrix) -> Matrix { let mid = c11.len(); let n = mid * 2; let mut p = vec![vec![0.0; n]; n]; for i in 0..mid { for j in 0..mid { p[i][j] = c11[i][j]; p[i][j + mid] = c12[i][j]; p[i + mid][j] = c21[i][j]; p[i + mid][j + mid] = c22[i][j]; } } p}fn strassen_multiply(a: &Matrix, b: &Matrix) -> Matrix { let n = a.len(); if n <= 64 { return naive_multiply(a, b); } let (a11, a12, a21, a22) = split_matrix(a); let (b11, b12, b21, b22) = split_matrix(b); let m1 = strassen_multiply(&add_matrices(&a11, &a22), &add_matrices(&b11, &b22)); let m2 = strassen_multiply(&add_matrices(&a21, &a22), &b11); let m3 = strassen_multiply(&a11, &subtract_matrices(&b12, &b22)); let m4 = strassen_multiply(&a22, &subtract_matrices(&b21, &b11)); let m5 = strassen_multiply(&add_matrices(&a11, &a12), &b22); let m6 = strassen_multiply(&subtract_matrices(&a21, &a11), &add_matrices(&b11, &b12)); let m7 = strassen_multiply(&subtract_matrices(&a12, &a22), &add_matrices(&b21, &b22)); let c11 = add_matrices(&subtract_matrices(&add_matrices(&m1, &m4), &m5), &m7); let c12 = add_matrices(&m3, &m5); let c21 = add_matrices(&m2, &m4); let c22 = add_matrices(&subtract_matrices(&add_matrices(&m1, &m3), &m2), &m6); combine_matrices(&c11, &c12, &c21, &c22)}fn main() { let args: Vec<String> = env::args().collect(); if args.len() != 2 { eprintln!("Usage: {} <n>", args[0]); return; } let n: usize = args[1].parse().expect("Please provide a valid integer for n"); if !n.is_power_of_two() { eprintln!("Error: n must be a power of 2."); return; } println!("--- Rust Matrix Multiplication (n={}) ---", n); let a = create_matrix(n); let b = create_matrix(n); let mut peak: f64 = 0.0; let start = Instant::now(); let _ = naive_multiply(&a, &b); peak = peak.max(get_memory_mb()); let duration = start.elapsed(); println!("Naive Algorithm Time: {:.6?} seconds", duration.as_secs_f64()); let start = Instant::now(); let _ = strassen_multiply(&a, &b); peak = peak.max(get_memory_mb()); let duration = start.elapsed(); println!("Strassen Algorithm Time: {:.6?} seconds", duration.as_secs_f64()); println!("Peak RAM (MB): {:.2}", peak);}